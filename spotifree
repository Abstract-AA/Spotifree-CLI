#!/bin/bash

set -e

for cmd in yt-dlp mpv; do
  command -v $cmd >/dev/null 2>&1 || { echo "$cmd is required but not installed. Aborting."; exit 1; }
done

AUDIO_FORMAT="mp3"
TMP_DIR="/tmp/ytmp3"
AUDIO_QUALITY="64"  # Default quality in kbps
if [ -d "$HOME/Music" ]; then
    TARGET_DIR="$HOME/Music"
else
    TARGET_DIR="/"
fi
mkdir -p "$TMP_DIR" "$TARGET_DIR"
LAST_STREAM_URL=""
LAST_QUERY=""
declare -A SONG_CACHE
LOCAL_PLAYLIST=()
HISTORY=()
CACHE_LIMIT=20
LOOP_MODE=false
SEARCH_RESULTS_SIZE=10
cols=$(tput cols)
lines=$(tput lines)
trap 'cols=$(tput cols); lines=$(tput lines)' WINCH # Updates the dimensions whenever the user resizes

center() {
    local text="$1"
    local pad=$(( (cols - ${#text}) / 2 ))
    [[ $pad -le 0 ]] && pad=0
    printf "%*s%s\n" "$pad" "" "$text"
}

hr() {
    local char="${1:--}"      # Default to '-' if no argument is given
    local cols=$(tput cols)   # Get terminal width
    printf '%*s\n' "$cols" '' | tr ' ' "$char"
}

hr_text() {
    local char="$1"  # Fill character
    local text="$2"  # Text to display
    local position_factor="${3:-2}"  # Default to center (2) if not provided
    local cols=$(tput cols)
    local text_len=${#text} 
    if ! [[ "$position_factor" =~ ^[1-9][0-9]*$ ]]; then
        echo "Error: position must be a positive integer" >&2
        return 1
    fi    
    local total_fill=$(( cols - text_len )) # Calculate total fill space needed      
    if (( total_fill < 0 )); then # Ensure we don't have negative fill space
        echo "$text"
        return
    fi   
    local left_fill=$(( total_fill / position_factor )) # Calculate left fill based on position_factor
    local right_fill=$(( total_fill - left_fill ))
    printf '%*s' "$left_fill" '' | tr ' ' "$char" # Print the line
    printf "%s" "$text"
    printf '%*s\n' "$right_fill" '' | tr ' ' "$char"
}

print_header() {
  clear
  center "                            ____           __   _  ___                                       "
  center "  ____ ____ ____ ____      / __/___  ___  / /_ (_)/ _/____ ___  ___       ____ ____ ____ ____"
  center " /___//___//___//___/     _\ \ / _ \/ _ \/ __// // _// __// -_)/ -_)     /___//___//___//___/"
  center "/___//___//___//___/     /___// .__/\___/\__//_//_/ /_/   \__/ \__/     /___//___//___//___/ "
  center "                             /_/                                                             "
  echo
  center "                                   Your Free Music Platform                                  "
  hr
}

print_main_header() {
    center "| [Space] Play/Pause   [←/→] Seek 5s  [↓/↑] Seek 1m   [9/0] Vol -/+   [s] Settings   [q] Quit |"
    center "| [r] Repeat   [h] Streaming History  [d] Download last streamed song  [l] Browse Local Files |"
    hr_text "-" "[ Last streamed song : ${LAST_QUERY:-none} ]"
}

print_browser_header() {
    center "| [Space] Play/Pause      [←/→] Seek 5s      [↓/↑] Seek 1m       [9/0] Vol -/+       [q] Quit|"
    center "|      [p] Play local song playlist      [v] View playlist      [c] Clear playlist           |"
    center "| [# + -r] Loop song    [# + -p] Add to playlist (e.g. '1 -p')   [#,#] Serial play (e.g. 1,4)|"
    hr
}

print_main_menu(){
    center "=========================[ Main Menu ]========================="
    center "  Enter a song name to start listening                         "
    center "  Enter multiple songs separated by asterisks for a playlist   "
    center "  Add '-r' at the end to loop a song (e.g., 'song -r')         "
    center "  Add '-l' at the end to show a list of results                "
    center "==============================================================="
}

play_stream() {
  local stream_url="$1"
  local loop="$2"
  if [ "$loop" = true ]; then
    echo
    hr "_"
    mpv --no-video --loop "$stream_url" --msg-level=ffmpeg=no,network=no
  else
  echo
    hr "_"
    mpv --no-video "$stream_url" --msg-level=ffmpeg=no,network=no
  fi
  sleep 1
}

browse_local_files() {
  local start_dir="$1"
  local current_dir
  if [[ -z "$start_dir" || ! -d "$start_dir" ]]; then
    start_dir="$TARGET_DIR"
  fi
  current_dir="$start_dir"
  while true; do
    clear
    print_header
    print_browser_header
    echo
    hr_text "=" "[ Browsing: $current_dir ]"
    local items=()
    local index=1
    echo "  b. .. (return to previous directory)"
    while IFS= read -r entry; do # List folders first, then files
      items+=("$entry")
    done < <(find "$current_dir" -maxdepth 1 -mindepth 1 -type d | sort)

    while IFS= read -r entry; do
      items+=("$entry")
    done < <(find "$current_dir" -maxdepth 1 -mindepth 1 -type f | sort)

    for i in "${!items[@]}"; do
      entry_name="${items[$i]}"
      base_name="$(basename "$entry_name")"
      if [[ -d "$entry_name" ]]; then
        printf "  %d. \e[1m%s\e[0m\n" $((i+1)) "$base_name"
      else
        printf "  %d. %s\n" $((i+1)) "$base_name"
      fi
    done
    hr "="
    echo "  Current playlist size: (${#LOCAL_PLAYLIST[@]} files)"
    echo -n "  Enter number >>> "
    read -r -a input_parts

    local loop=false
    local mark_only=false
    local numbers=()

    for arg in "${input_parts[@]}"; do
      case "$arg" in
        -r) loop=true ;;
        -p) mark_only=true ;;
        p)  
          if [[ ${#LOCAL_PLAYLIST[@]} -eq 0 ]]; then
    	    echo "  The playlist is empty."
            sleep 1
            continue 2
          else
            echo "  Playing playlist..."
            echo
            mpv --no-video "${LOCAL_PLAYLIST[@]}"
          fi
          sleep 1
          continue 2
          ;;
        c)
          LOCAL_PLAYLIST=()
          echo "  Playlist cleared."
          sleep 1
          continue 2
          ;;
        b) current_dir=$(dirname "$current_dir"); continue 2 ;;
        v)
          echo
          hr_text "-" "[ Playlist Contents ]" "10"
          if [[ ${#LOCAL_PLAYLIST[@]} -eq 0 ]]; then
            echo "  Playlist is empty."
          else
            for i in "${!LOCAL_PLAYLIST[@]}"; do
              path="${LOCAL_PLAYLIST[$i]}"
              name=$(basename "$path")
              printf "  %2d. %s\n" $((i+1)) "$name"
            done
          fi
          hr
          echo
          read -rp "  Press enter to continue..." _
          continue 2
          ;;
        b) current_dir=$(dirname "$current_dir"); continue 2 ;;
        q) break 2 ;;
        *,*) IFS=',' read -ra numbers <<< "$arg" ;;
        [0-9]*) numbers+=("$arg") ;;
        q) break 2 ;;
        *,*) IFS=',' read -ra numbers <<< "$arg" ;;
        [0-9]*) numbers+=("$arg") ;;
      esac
    done

    for num in "${numbers[@]}"; do
      if [[ "$num" =~ ^[0-9]+$ ]] && ((num >= 1 && num <= ${#items[@]})); then
        selected="${items[$((num - 1))]}"
        if [[ -d "$selected" ]]; then
          current_dir="$selected"
          break
        elif [[ -f "$selected" && "$selected" =~ \.(mp3|m4a|opus|flac|wav|ogg)$ ]]; then
          if [[ "$mark_only" == true ]]; then
            LOCAL_PLAYLIST+=("$selected")
            echo "  Added to playlist: $(basename "$selected")"
            sleep 0.5
          else
            echo
            echo "  >Now playing: $(basename "$selected")"
            if [ "$loop" = true ]; then
              echo "  Loop mode activated"
              echo
              mpv --no-video --loop "$selected"
            else
            echo
              mpv --no-video "$selected"
            fi
            sleep 1
          fi
        else
          echo "  Unsupported file type."
          sleep 1
        fi
      else
        echo "  Invalid input: $num"
        sleep 1
      fi
    done
  done
}

search_with_list() {
  local query="$1"
  local loop="$2"
  printf "%*sSearching for: $query" $(( (cols-62)/2 ))
  # Start spinner animation in background
  (cols=$(tput cols); padding=$(( (cols - 62) / 2 )); while :; do for var in / - \\ \|; do printf "\r%*sSearching for: %s %s" "$padding" "" "$query" "$var"; sleep 0.1; done; done) &
  LOAD_PID=$!
  disown $LOAD_PID
  local search_results # Perform the actual search
  search_results=$(yt-dlp "ytsearch${SEARCH_RESULTS_SIZE}:$query" --print "%(title)s | %(id)s | %(duration_string)s" 2>/dev/null) || {
    kill "$LOAD_PID" &>/dev/null
    printf "\n%*sFailed to search for: $query" $(( (cols-62)/2 ))
    read -n 1 -s -r -p "$(printf "\n%*sPress any key to continue." $(( (cols-62)/2 )))"
    return 0
  }  
  kill "$LOAD_PID" &>/dev/null # Kill the spinner
  wait "$LOAD_PID" 2>/dev/null
  
  if [ -z "$search_results" ]; then
    printf "\n%*sNo results found for: $query" $(( (cols-62)/2 ))
    read -n 1 -s -r -p "$(printf "\n%*sPress any key to continue." $(( (cols-62)/2 )))"
    return 0
  fi 
  echo
  echo
  hr_text "-" "[ Search Results ]" "10"
  local i=1
  while IFS= read -r line; do
    # Split the line into parts
    IFS="|" read -r title id duration <<< "$line"
    printf " %d. %s (%s)\n" "$i" "$(echo "$title" | xargs)" "$(echo "$duration" | xargs)"
    i=$((i+1))
  done <<< "$search_results"
  hr   
  echo -n " Select a song (1-$SEARCH_RESULTS_SIZE) or 'q' to cancel: " # Get user selection
  read -r choice  
  if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= SEARCH_RESULTS_SIZE)); then
    # Extract the selected video ID
    local selected_line=$(echo "$search_results" | sed -n "${choice}p")
    local video_id=$(echo "$selected_line" | awk -F '|' '{print $2}' | xargs)
    local video_title=$(echo "$selected_line" | awk -F '|' '{print $1}' | xargs)   
    
    echo " Selected: $video_title"    
    stream_url=$(yt-dlp -f bestaudio -g "$video_id") || return 1    
    LAST_STREAM_URL="$stream_url"
    LAST_QUERY="$video_title"
    add_to_history "$video_title" "$stream_url"
    clear
    print_header
    print_main_header
    echo
    print_main_menu
    printf "%*sNow playing: $video_title" $(( (cols-62)/2 ))
    echo
    play_stream "$stream_url" "$loop"
  else
    echo " Cancelled."
    sleep 1
  fi
}

add_to_history() {
  local query="$1"
  local url="$2"
  
  local clean_query="${query%% -r}" # This will remove -r flag if present before adding to history
  
  if [[ -z "${SONG_CACHE[$clean_query]}" ]]; then
    SONG_CACHE["$clean_query"]="$url"
    HISTORY+=("$clean_query")
    
    if [[ ${#HISTORY[@]} -gt $CACHE_LIMIT ]]; then
      local oldest_query="${HISTORY[0]}"
      unset SONG_CACHE["$oldest_query"]
      HISTORY=("${HISTORY[@]:1}")
    fi
  fi
}

show_history() {
  if [[ ${#HISTORY[@]} -eq 0 ]]; then
    printf "%*sNo songs in history yet!" $(( (cols-62)/2 )) 
    sleep 1
    return
  fi
  echo
  center "================[ Recently Streamed (Last $CACHE_LIMIT) ]================"
  for i in "${!HISTORY[@]}"; do 
    center "$((i+1)). ${HISTORY[$i]}"
  done
  center "==============================================================="
  echo
  
  printf "%*sEnter number (or any key to cancel): " $(( (cols-62)/2 )) 
  read -r choice
  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#HISTORY[@]} ]]; then
    local selected_query="${HISTORY[$((choice-1))]}"
    printf "%*sReplay options: [1] Once  [2] Loop  [3] Cancel:" $(( (cols-62)/2 ))
    read -r mode
    case "$mode" in
      1)
        clear && print_header && print_main_header && echo && print_main_menu 
        printf "%*sPlaying: $selected_query" $(( (cols-62)/2 )) && echo
        LAST_STREAM_URL="${SONG_CACHE[$selected_query]}"
        LAST_QUERY="$selected_query"
        play_stream "${SONG_CACHE[$selected_query]}" false
        ;;
      2)
        clear && print_header && print_main_header && echo && print_main_menu 
        printf "%*sLooping: $selected_query" $(( (cols-62)/2 )) && echo
        LAST_STREAM_URL="${SONG_CACHE[$selected_query]}"
        LAST_QUERY="$selected_query"
        play_stream "${SONG_CACHE[$selected_query]}" true
        ;;
      *)
        printf "%*sCancelled." $(( (cols-62)/2 ))
        sleep 0.5
        ;;
    esac
  else
    printf "%*sCancelled." $(( (cols-62)/2 ))
  fi
}

download_last() {
  [ -z "$LAST_STREAM_URL" ] && {
    printf "%*sNo song to download! Please play a song first." $(( (cols-62)/2 ))
    sleep 0.5
    return 1
  }

  printf "%*sAudio Format: $AUDIO_FORMAT"   $(( (cols-62)/2 ))
  printf "\n%*sDestination:  $TARGET_DIR"    $(( (cols-62)/2 ))
  printf "\n%*sAudio Quality: ${AUDIO_QUALITY}kbps" $(( (cols-62)/2 ))

  # safe file-name stem
  clean_title=$(printf '%s' "$LAST_QUERY" | tr -cd '[:alnum:][:space:]' | tr ' ' '_')
  temp_file="${TMP_DIR}/${clean_title}.opus"          # we always grab opus first
  final_file="${TARGET_DIR}/${clean_title}.${AUDIO_FORMAT}"

  # spinner
  (cols=$(tput cols); padding=$(( (cols - 62) / 2 )); while :; do for var in / - \\ \|; do printf "\r%*s%s Downloading: %s, please wait..." "$padding" "" "$var" "$LAST_QUERY"; sleep 0.1; done; done) &
  LOAD_PID=$!
  disown $LOAD_PID

  yt-dlp --quiet --no-warnings --extract-audio --audio-format opus \
         --audio-quality "${AUDIO_QUALITY}k" -o "$temp_file" "$LAST_STREAM_URL"
  dl_st=$?

  kill $LOAD_PID 2>/dev/null
  if [ $dl_st -ne 0 ]; then
    printf "%*sDownload failed!" $(( (cols-62)/2 ))
    rm -f "$temp_file"
    read -n1 -srp "$(printf "\n%*sPress enter to continue…" $(( (cols-62)/2 )))"
    return 1
  fi
  
  case "${AUDIO_FORMAT,,}" in      # --------- ffmpeg switch-table ---------
    mp3)  codec_args=(-c:a libmp3lame -b:a "${AUDIO_QUALITY}k") ;;
    aac)  codec_args=(-c:a aac -b:a "${AUDIO_QUALITY}k") ;;
    ogg)  codec_args=(-c:a libvorbis -q:a 6) ;;
    opus) codec_args=(-c:a libopus -b:a "${AUDIO_QUALITY}k") ;;
    flac) codec_args=(-c:a flac) ;;
    *)    codec_args=(-c:a copy) ;;   # fallback
  esac
  
  # spinner for conversion
  (cols=$(tput cols); padding=$(( (cols - 62) / 2 )); while :; do for var in / - \\ \|; do printf "\r%*s%s Converting to MP3..." "$padding" "" "$var"; sleep 0.1; done; done) &
  LOAD_PID=$!
  disown $LOAD_PID

  ffmpeg -v quiet -stats -i "$temp_file" -vn "${codec_args[@]}" "$final_file"
  conv_st=$?

  kill $LOAD_PID 2>/dev/null
  if [ $conv_st -eq 0 ]; then
    printf "\n%*sConversion complete!" $(( (cols-62)/2 ))
    rm -f "$temp_file"
    printf "\n%*sSaved: "$final_file" " $(( (cols-62)/2 )) 
    read -n1 -srp "$(printf "\n%*sPress enter to continue…" $(( (cols-62)/2 )))"
    return 0
  else
    printf "\n%*sConversion failed!" $(( (cols-62)/2 ))
    rm -f "$temp_file" "$final_file"
    read -n1 -srp "$(printf "\n%*sPress enter to continue…" $(( (cols-62)/2 )))"
    return 1
  fi
}

settings_menu() {
  while true; do
    print_header
    echo
    center "========================[ Settings ]========================"
    center "1. Current download directory: $TARGET_DIR"
    center "2. Current audio quality: ${AUDIO_QUALITY}kbps"
    center "3. Current search list size: ${SEARCH_RESULTS_SIZE}"
    center "4. Current download file format: $AUDIO_FORMAT"
    center "============================================================"
    printf "%*sEnter option number to change (q to return to main menu)" $(( (cols-62)/2 )) 
    printf "\n%*s>>>" $(( (cols-62)/2 )) 
    ##echo -n ">>> "
    read -r reply    
    case "$reply" in
      q)
        return 0
        ;;
      1)
        echo
        printf "%*sCurrent download directory: $TARGET_DIR" $(( (cols-62)/2 )) 
        printf "\n%*sEnter new directory path (or leave blank to keep current):" $(( (cols - 62) / 2 ))
        echo
        printf "%*s>>>" $(( (cols-62)/2 )) ""       
        read -r new_dir
        if [ -n "$new_dir" ]; then
          if [ -d "$new_dir" ]; then
            TARGET_DIR="$new_dir"
            mkdir -p "$TARGET_DIR" 
            printf "%*sDownload directory changed to: $TARGET_DIR" $(( (cols-62)/2 )) 
          else
            printf "%*sDirectory does not exist. Would you like to create it? (y/n):" $(( (cols-62)/2 )) 
            read -r create_dir
            if [ "$create_dir" = "y" ]; then
              mkdir -p "$new_dir"
              if [ $? -eq 0 ]; then
                TARGET_DIR="$new_dir"
                printf "%*sDownload directory changed to: $TARGET_DIR" $(( (cols-62)/2 )) 
              else
                printf "%*sFailed to create directory. Please check permissions." $(( (cols-62)/2 )) 
              fi
            else
              printf "%*sDirectory not changed." $(( (cols-62)/2 )) ""
            fi
          fi
        fi
        ;;
      2)
        center "==========================================="
        center "|     (not applicable to FLAC files)      |"
        center "|  1. 64kbps (fastest, lowest quality)    |"
        center "|  2. 128kbps                             |"
        center "|  3. 192kbps                             |"
        center "|  4. 256kbps                             |"
        center "|  5. 320kbps (slowest, best quality)     |"
        center "==========================================="
        printf "%*sEnter choice (1-5):" $(( (cols-62)/2 )) ""
        read -r quality_choice       
        case "$quality_choice" in
          1) AUDIO_QUALITY="64" ;;
          2) AUDIO_QUALITY="128" ;;
          3) AUDIO_QUALITY="192" ;;
          4) AUDIO_QUALITY="256" ;;
          5) AUDIO_QUALITY="320" ;;
          *)
            printf "%*sInvalid choice. Audio quality remains unchanged" $(( (cols-62)/2 ))
            sleep 0.5
            ;;
        esac
        printf "\n%*sCurrently selected audio quality: ${AUDIO_QUALITY}kbps" $(( (cols - 62) / 2 ))
        sleep 0.5
        ;;
       3)
        printf "%*sCurrent search results size: $SEARCH_RESULTS_SIZE" $(( (cols-62)/2 ))
        printf "\n%*sEnter new search results size (1-50):" $(( (cols - 62) / 2 ))
  	read -r new_size
  	if [[ "$new_size" =~ ^[0-9]+$ ]] && ((new_size >= 1 && new_size <= 50)); then
    	  SEARCH_RESULTS_SIZE=$new_size
    	  printf "\n%*sSearch results size set to: $SEARCH_RESULTS_SIZE" $(( (cols - 62) / 2 ))
  	else
  	  printf "\n%*sInvalid size. Must be between 1 and 50." $(( (cols - 62) / 2 ))
  	fi
  	;;
       4)
        center "======================================"
        center "|   1. MP3   (libmp3lame)            |"
        center "|   2. AAC   (native aac)            |"
        center "|   3. OGG   (libvorbis)             |"
        center "|   4. OPUS  (libopus)               |"
        center "|   5. FLAC  (flac)                  |"
        center "======================================"
        printf "%*sEnter choice (1-5):" $(( (cols-62)/2 )) ""
        read -r fmt_choice        
        case "$fmt_choice" in
          1) AUDIO_FORMAT="mp3"  ;;
          2) AUDIO_FORMAT="aac"  ;;
          3) AUDIO_FORMAT="ogg"  ;;
          4) AUDIO_FORMAT="opus" ;;
          5) AUDIO_FORMAT="flac" ;;
          *)
            printf "%*sInvalid choice. Audio format remains unchanged" $(( (cols-62)/2 ))
            sleep 0.5
            ;;
        esac
        printf "\n%*sCurrently selected Audio format: ${AUDIO_FORMAT}" $(( (cols - 62) / 2 ))
        sleep 0.5
        ;;
      *)
        printf "%*sInvalid option" $(( (cols-62)/2 ))
        ;;
    esac    
    sleep 1
  done
}

process_song() {
  local query="$1"
  local loop=false
  local list_mode=false
  # Check for flags
  if [[ "$query" == *" -r" ]]; then
    loop=true
    query="${query%% -r}" # Remove the -r flag
  fi
  if [[ "$query" == *" -l" ]]; then
    list_mode=true
    query="${query%% -l}" # Remove the -l flag
  fi
  if [ "$list_mode" = true ]; then
    search_with_list "$query" "$loop"
  else
    printf "%*sSearching and streaming: $query " $(( (cols-62)/2 ))
    # This will start the spinner animation
    (cols=$(tput cols); padding=$(( (cols - 62) / 2 )); while :; do for var in / - \\ \|; do printf "\r%*s%s Searching and streaming: %s %s" "$padding" "" "$var" "$query"; sleep 0.1; done; done) &
    LOAD_PID=$!
    disown $LOAD_PID    
    stream_url=$(yt-dlp -f bestaudio -g "ytsearch1:$query" 2>/dev/null) || {                              
      kill "$LOAD_PID" &>/dev/null
      printf "%*sFailed to find stream for: $query" $(( (cols-62)/2 ))
      sleep 1
      return 0
    }    
    kill "$LOAD_PID" &>/dev/null # This will kill the spinner animation
    wait "$LOAD_PID" 2>/dev/null
    if [ -z "$stream_url" ]; then
      printf "\n%*sNo results found for: $query" $(( (cols-62)/2 ))
      read -n 1 -s -r -p "$(printf "\n%*sPress any key to continue." $(( (cols-62)/2 )))"
      return 0
    fi
    LAST_STREAM_URL="$stream_url"
    LAST_QUERY="$query"
    add_to_history "$query" "$stream_url"
    echo
    play_stream "$stream_url" "$loop"
  fi
  return 0
}

main_loop() {
  while true; do
    print_header
    print_main_header
    echo
    print_main_menu
    printf "%*s>>> Enter your choice: " $(( (cols-62)/2 )) ""
    read -r input    
    case "$input" in
      q)
        exit 0
        ;;
      r)
        if [ -z "$LAST_STREAM_URL" ]; then
          printf "%*sNo song to repeat! Please search for a song first." $(( (cols-62)/2 ))
          sleep 1
          continue
        fi
        printf "%*sRepeat options: [1] Once  [2] Loop  [3] Cancel: " $(( ( $(tput cols) - 62 ) / 2 ))
        read -r mode
        case "$mode" in
          1)
            printf "%*sRepeating: $LAST_QUERY" $(( (cols-62)/2 ))
            play_stream "$LAST_STREAM_URL" false
            ;;
          2)
            printf "%*sLooping: $LAST_QUERY" $(( (cols-62)/2 ))
            play_stream "$LAST_STREAM_URL" true
            ;;
          *)
            printf "%*sCancelled." $(( (cols-62)/2 )) ""
            ;;
        esac
        ;;
      h)
        show_history
        ;;
      d)
        if ! download_last; then
          sleep 2
        fi
        ;;
      s)
        settings_menu
        ;;
      l)
        browse_local_files "$HOME/Music"
        ;;
      *)
        if [[ -z "$input" ]]; then
         printf "%*sNo input entered. Returning to menu..." $(( (cols-62)/2 ))
         sleep 1
         continue
        fi      
        if [[ "$input" == *** ]]; then # this will handle the *-separated playlist
          IFS='*' read -ra songs <<< "$input"
          for song in "${songs[@]}"; do
            song=$(echo "$song" | xargs) # this trims whitespace has to be here
            [ -z "$song" ] && continue
            process_song "$song"
          done
        else
          process_song "$input"
        fi
        ;;
    esac
  done
}
main_loop
